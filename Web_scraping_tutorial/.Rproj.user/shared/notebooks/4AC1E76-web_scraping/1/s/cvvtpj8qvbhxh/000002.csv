"0","get_review_dates <- function(html){"
"0","      status <- html %>% "
"0","                  html_nodes('time') %>% "
"0","                  # The status information is this time a tag attribute"
"0","                  html_attrs() %>%             "
"0","                  # Extract the second element"
"0","                  map(2) %>%                    "
"0","                  unlist() "
"0","      dates <- html %>% "
"0","                  html_nodes('time') %>% "
"0","                  html_attrs() %>% "
"0","                  map(1) %>% "
"0","                  # Parse the string into a datetime object with lubridate"
"0","                  ymd_hms() %>%                 "
"0","                  unlist()"
"0","      # Combine the status and the date information to filter one via the other"
"0","      return_dates <- tibble(status = status, dates = dates) %>%   "
"0","                        # Only these are actual reviews"
"0","                        filter(status == 'ndate') %>%              "
"0","                        # Select and convert to vector"
"0","                        pull(dates) %>%                            "
"0","                        # Convert DateTimes to POSIX objects"
"0","                        as.POSIXct(origin = '1970-01-01 00:00:00') "
"0","      # The lengths still occasionally do not lign up. You then arbitrarily crop the dates to fit"
"0","      # This can cause data imperfections, however reviews on one page are generally close in time)"
"0","      length_reviews <- length(get_reviews(html))"
"0","      return_reviews <- if (length(return_dates)> length_reviews){"
"0","          return_dates[1:length_reviews]"
"0","        } else{"
"0","          return_dates"
"0","        }"
"0","      return_reviews"
"0","    }"
